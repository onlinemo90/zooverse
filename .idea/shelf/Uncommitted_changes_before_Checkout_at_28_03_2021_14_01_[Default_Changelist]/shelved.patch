Index: app/src/main/java/com/zooverse/model/database/DatabaseHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.zooverse.model.database;\r\n\r\nimport android.content.ContentValues;\r\nimport android.database.Cursor;\r\nimport android.database.sqlite.SQLiteDatabase;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.util.Pair;\r\n\r\nimport com.zooverse.AssetManager;\r\nimport com.zooverse.MainApplication;\r\nimport com.readystatesoftware.sqliteasset.SQLiteAssetHelper;\r\nimport com.zooverse.model.Group;\r\nimport com.zooverse.model.Individual;\r\nimport com.zooverse.model.Species;\r\nimport com.zooverse.model.Ticket;\r\n\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class DatabaseHandler extends SQLiteAssetHelper {\r\n\tprivate static final int DATABASE_VERSION = 60;\r\n\t\r\n\tprivate static final SimpleDateFormat dateFormat = new SimpleDateFormat(DatabaseContract.DATE_FORMAT);\r\n\t\r\n\tprivate final SQLiteDatabase database;\r\n\t\r\n\tpublic DatabaseHandler() {\r\n\t\tsuper(MainApplication.getContext(), AssetManager.DATABASE_NAME, null, DATABASE_VERSION);\r\n\t\tthis.setForcedUpgrade();\r\n\t\t\r\n\t\tthis.database = getReadableDatabase();\r\n\t}\r\n\t\r\n\t// Ticket-----------------------------------------------------------\r\n\tpublic List<Ticket> getStoredTickets(Date afterDate) {\r\n\t\tString afterDateString = dateFormat.format(afterDate);\r\n\t\tString[] columns = {\r\n\t\t\t\tDatabaseContract.TicketEntry.COLUMN_ZOO_ID,\r\n\t\t\t\tDatabaseContract.TicketEntry.COLUMN_DATE\r\n\t\t};\r\n\t\tString selection = DatabaseContract.TicketEntry.COLUMN_DATE + \" >= ?\";\r\n\t\tString[] selectionArgs = new String[]{afterDateString};\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.TicketEntry.TABLE_NAME,\r\n\t\t\t\tcolumns,\r\n\t\t\t\tselection,\r\n\t\t\t\tselectionArgs,\r\n\t\t\t\tnull,\r\n\t\t\t\tnull,\r\n\t\t\t\tDatabaseContract.TicketEntry.COLUMN_DATE + \" ASC\"\r\n\t\t);\r\n\t\t\r\n\t\t// Parse data into List\r\n\t\tList<Ticket> ticketList = new ArrayList<>();\r\n\t\tString zooID;\r\n\t\tDate date;\r\n\t\twhile (cursor.moveToNext()) {\r\n\t\t\tzooID = cursor.getString(cursor.getColumnIndex(DatabaseContract.TicketEntry.COLUMN_ZOO_ID));\r\n\t\t\ttry {\r\n\t\t\t\tdate = dateFormat.parse(cursor.getString(cursor.getColumnIndex(DatabaseContract.TicketEntry.COLUMN_DATE)));\r\n\t\t\t} catch (ParseException e) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tticketList.add(new Ticket(zooID, date));\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\treturn ticketList;\r\n\t}\r\n\t\r\n\tpublic boolean hasTodayTicket(){\r\n\t\tString todayDateStr = dateFormat.format(new Date());\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.TicketEntry.TABLE_NAME,\r\n\t\t\t\tnew String[]{},\r\n\t\t\t\tDatabaseContract.TicketEntry.COLUMN_DATE + \"= ?\",\r\n\t\t\t\tnew String[]{todayDateStr},\r\n\t\t\t\tnull, null, null\r\n\t\t);\r\n\t\tboolean hasTodayTicket = cursor.moveToNext();\r\n\t\tcursor.close();\r\n\t\treturn hasTodayTicket;\r\n\t}\r\n\t\r\n\tpublic void storeTicket(Ticket ticket) {\r\n\t\tContentValues insertValues = new ContentValues();\r\n\t\tinsertValues.put(DatabaseContract.TicketEntry.COLUMN_ZOO_ID, ticket.getZooID());\r\n\t\tinsertValues.put(DatabaseContract.TicketEntry.COLUMN_DATE, dateFormat.format(ticket.getDate()));\r\n\t\tdatabase.insert(\r\n\t\t\t\tDatabaseContract.TicketEntry.TABLE_NAME,\r\n\t\t\t\tnull,\r\n\t\t\t\tinsertValues\r\n\t\t);\r\n\t}\r\n\t\r\n\t// Groups----------------------------------------------------------\r\n\tpublic Map<Integer, Group> getAllGroups() {\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.GroupEntry.TABLE_NAME,\r\n\t\t\t\tnew String[]{\r\n\t\t\t\t\t\tDatabaseContract.GroupEntry._ID,\r\n\t\t\t\t\t\tDatabaseContract.GroupEntry.COLUMN_NAME,\r\n\t\t\t\t\t\tDatabaseContract.GroupEntry.COLUMN_IMAGE\r\n\t\t\t\t},\r\n\t\t\t\tnull, null, null, null,\r\n\t\t\t\tDatabaseContract.GroupEntry.COLUMN_NAME + \" ASC\"\r\n\t\t);\r\n\t\t\r\n\t\tMap<Integer, Group> groupMap = new HashMap<>();\r\n\t\tint id;\r\n\t\tString name;\r\n\t\tbyte[] imageBlob;\r\n\t\t\r\n\t\tGroup tmpGroup;\r\n\t\twhile (cursor.moveToNext()) {\r\n\t\t\tid = cursor.getInt(cursor.getColumnIndex(DatabaseContract.GroupEntry._ID));\r\n\t\t\tname = cursor.getString(cursor.getColumnIndex(DatabaseContract.GroupEntry.COLUMN_NAME));\r\n\t\t\timageBlob = cursor.getBlob(cursor.getColumnIndex(DatabaseContract.GroupEntry.COLUMN_IMAGE));\r\n\t\t\tif (imageBlob != null)\r\n\t\t\t\ttmpGroup = new Group(id, name, BitmapFactory.decodeByteArray(imageBlob, 0, imageBlob.length), getGroupAttributes(id));\r\n\t\t\telse\r\n\t\t\t\ttmpGroup = new Group(id, name, null, getGroupAttributes(id));\r\n\t\t\t\r\n\t\t\tgroupMap.put(id, tmpGroup);\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\treturn groupMap;\r\n\t}\r\n\t\r\n\tprivate List<Pair<String,String>> getGroupAttributes(int groupID){\r\n\t\treturn getAttributes(groupID, DatabaseContract.GroupAttributesEntry.TABLE_NAME);\r\n\t}\r\n\t\r\n\tpublic Map<Integer, List<Integer>> getGroupsSpeciesIdsMap(){\r\n\t\tMap<Integer, List<Integer>> groupsSpeciesMap = new HashMap<>();\r\n\t\t\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.GroupsSpeciesEntry.TABLE_NAME,\r\n\t\t\t\tnew String[]{\r\n\t\t\t\t\t\tDatabaseContract.GroupsSpeciesEntry._ID,\r\n\t\t\t\t\t\tDatabaseContract.GroupsSpeciesEntry.COLUMN_GROUP_ID,\r\n\t\t\t\t\t\tDatabaseContract.GroupsSpeciesEntry.COLUMN_SPECIES_ID\r\n\t\t\t\t},\r\n\t\t\t\tnull, null, null, null, null\r\n\t\t);\r\n\t\tint groupId, speciesId;\r\n\t\twhile (cursor.moveToNext()) {\r\n\t\t\tgroupId = cursor.getInt(cursor.getColumnIndex(DatabaseContract.GroupsSpeciesEntry.COLUMN_GROUP_ID));\r\n\t\t\tspeciesId = cursor.getInt(cursor.getColumnIndex(DatabaseContract.GroupsSpeciesEntry.COLUMN_SPECIES_ID));\r\n\t\t\tif (!groupsSpeciesMap.containsKey(groupId)){\r\n\t\t\t\tgroupsSpeciesMap.put(groupId, new ArrayList<>());\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tgroupsSpeciesMap.get(groupId).add(speciesId);\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\treturn groupsSpeciesMap;\r\n\t}\r\n\t\r\n\t// Species----------------------------------------------------------\r\n\tpublic Map<Integer, Species> getAllSpecies() {\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.SpeciesEntry.TABLE_NAME,\r\n\t\t\t\tnew String[]{\r\n\t\t\t\t\t\tDatabaseContract.SpeciesEntry._ID,\r\n\t\t\t\t\t\tDatabaseContract.SpeciesEntry.COLUMN_NAME,\r\n\t\t\t\t\t\tDatabaseContract.SpeciesEntry.COLUMN_IMAGE,\r\n\t\t\t\t\t\tDatabaseContract.SpeciesEntry.COLUMN_LOCATION_ID,\r\n\t\t\t\t\t\tDatabaseContract.SpeciesEntry.COLUMN_WEIGHT,\r\n\t\t\t\t\t\tDatabaseContract.SpeciesEntry.COLUMN_SIZE\r\n\t\t\t\t},\r\n\t\t\t\tnull, null, null, null,\r\n\t\t\t\tDatabaseContract.SpeciesEntry.COLUMN_NAME + \" ASC\"\r\n\t\t);\r\n\t\tMap<Integer, Species> speciesMap = new HashMap<>();\r\n\t\tint id;\r\n\t\tString name, weight, size;\r\n\t\tbyte[] imageBlob;\r\n\t\tPair<Double, Double> location;\r\n\t\tList<Pair<String, String>> attributes;\r\n\t\tSpecies tmpSpecies;\r\n\t\twhile (cursor.moveToNext()) {\r\n\t\t\tid = cursor.getInt(cursor.getColumnIndex(DatabaseContract.SpeciesEntry._ID));\r\n\t\t\tname = cursor.getString(cursor.getColumnIndex(DatabaseContract.SpeciesEntry.COLUMN_NAME));\r\n\t\t\timageBlob = cursor.getBlob(cursor.getColumnIndex(DatabaseContract.SpeciesEntry.COLUMN_IMAGE));\r\n\t\t\tlocation = this.getLocation(cursor.getInt(cursor.getColumnIndex(DatabaseContract.SpeciesEntry.COLUMN_LOCATION_ID)));\r\n\t\t\tweight = cursor.getString(cursor.getColumnIndex(DatabaseContract.SpeciesEntry.COLUMN_WEIGHT));\r\n\t\t\tsize = cursor.getString(cursor.getColumnIndex(DatabaseContract.SpeciesEntry.COLUMN_SIZE));\r\n\t\t\tattributes = this.getSpeciesAttributes(id);\r\n\t\t\tif (imageBlob != null)\r\n\t\t\t\ttmpSpecies = new Species(id, name, BitmapFactory.decodeByteArray(imageBlob, 0, imageBlob.length), weight, size, attributes, location);\r\n\t\t\telse\r\n\t\t\t\ttmpSpecies = new Species(id, name, null, weight, size, attributes, location);\r\n\t\t\ttmpSpecies.setIndividuals(this.getSpeciesIndividuals(tmpSpecies));\r\n\t\t\tspeciesMap.put(id, tmpSpecies);\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\treturn speciesMap;\r\n\t}\r\n\t\r\n\tprivate List<Pair<String,String>> getSpeciesAttributes(int speciesID){\r\n\t\treturn getAttributes(speciesID, DatabaseContract.SpeciesAttributesEntry.TABLE_NAME);\r\n\t}\r\n\t\r\n\tpublic byte[] getSpeciesAudio(int speciesID) {\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.SpeciesEntry.TABLE_NAME,\r\n\t\t\t\tnew String[]{DatabaseContract.SpeciesEntry.COLUMN_AUDIO},\r\n\t\t\t\tDatabaseContract.SpeciesEntry._ID + \" = ?\",\r\n\t\t\t\tnew String[]{String.valueOf(speciesID)},\r\n\t\t\t\tnull, null, null\r\n\t\t);\r\n\t\tcursor.moveToNext();\r\n\t\tbyte[] audioBlob = cursor.getBlob(cursor.getColumnIndex(DatabaseContract.SpeciesEntry.COLUMN_AUDIO));\r\n\t\tcursor.close();\r\n\t\treturn audioBlob;\r\n\t}\r\n\t\r\n\t// Individuals----------------------------------------------------------\r\n\tprivate List<Individual> getSpeciesIndividuals(Species species) {\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.IndividualEntry.TABLE_NAME,\r\n\t\t\t\tnew String[]{\r\n\t\t\t\t\t\tDatabaseContract.IndividualEntry._ID,\r\n\t\t\t\t\t\tDatabaseContract.IndividualEntry.COLUMN_NAME,\r\n\t\t\t\t\t\tDatabaseContract.IndividualEntry.COLUMN_DOB,\r\n\t\t\t\t\t\tDatabaseContract.IndividualEntry.COLUMN_PLACE_OF_BIRTH,\r\n\t\t\t\t\t\tDatabaseContract.IndividualEntry.COLUMN_GENDER,\r\n\t\t\t\t},\r\n\t\t\t\tDatabaseContract.IndividualEntry.COLUMN_SPECIES_ID + \" = ?\",\r\n\t\t\t\tnew String[]{Integer.toString(species.getId())},\r\n\t\t\t\tnull, null,\r\n\t\t\t\tDatabaseContract.IndividualEntry.COLUMN_NAME + \" ASC\"\r\n\t\t);\r\n\t\t\r\n\t\tList<Individual> individualList = new ArrayList<>();\r\n\t\tint id;\r\n\t\tString name, placeOfBirth, gender;\r\n\t\tDate dob = new Date();\r\n\t\twhile (cursor.moveToNext()) {\r\n\t\t\tid = cursor.getInt(cursor.getColumnIndex(DatabaseContract.IndividualEntry._ID));\r\n\t\t\tname = cursor.getString(cursor.getColumnIndex(DatabaseContract.IndividualEntry.COLUMN_NAME));\r\n\t\t\ttry {\r\n\t\t\t\tdob = dateFormat.parse(cursor.getString(cursor.getColumnIndex(DatabaseContract.IndividualEntry.COLUMN_DOB)));\r\n\t\t\t} catch (ParseException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\tplaceOfBirth = cursor.getString(cursor.getColumnIndex(DatabaseContract.IndividualEntry.COLUMN_PLACE_OF_BIRTH));\r\n\t\t\tgender = cursor.getString(cursor.getColumnIndex(DatabaseContract.IndividualEntry.COLUMN_GENDER));\r\n\t\t\t\r\n\t\t\tindividualList.add(new Individual(id, species, name, dob, placeOfBirth, gender, getIndividualAttributes(id)));\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\treturn individualList;\r\n\t}\r\n\t\r\n\tprivate List<Pair<String, String>> getIndividualAttributes(int individualID) {\r\n\t\treturn getAttributes(individualID, DatabaseContract.IndividualAttributesEntry.TABLE_NAME);\r\n\t}\r\n\t\r\n\tpublic Bitmap getIndividualImage(int individualID) {\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.IndividualEntry.TABLE_NAME,\r\n\t\t\t\tnew String[]{\r\n\t\t\t\t\t\tDatabaseContract.IndividualEntry.COLUMN_IMAGE\r\n\t\t\t\t},\r\n\t\t\t\tDatabaseContract.IndividualEntry._ID + \" = ?\",\r\n\t\t\t\tnew String[]{Integer.toString(individualID)},\r\n\t\t\t\tnull, null, null\r\n\t\t);\r\n\t\tcursor.moveToNext();\r\n\t\tbyte[] imageBlob = cursor.getBlob(cursor.getColumnIndex(DatabaseContract.IndividualEntry.COLUMN_IMAGE));\r\n\t\tcursor.close();\r\n\t\tif (imageBlob != null)\r\n\t\t\treturn BitmapFactory.decodeByteArray(imageBlob, 0, imageBlob.length);\r\n\t\telse\r\n\t\t\treturn null;\r\n\t}\r\n\t\r\n\t// Other----------------------------------------------------------------\r\n\tprivate Pair<Double, Double> getLocation(int locationID) {\r\n\t\tCursor cursor = database.query(\r\n\t\t\t\tDatabaseContract.LocationEntry.TABLE_NAME,\r\n\t\t\t\tnew String[]{\r\n\t\t\t\t\t\tDatabaseContract.LocationEntry.COLUMN_LATITUDE,\r\n\t\t\t\t\t\tDatabaseContract.LocationEntry.COLUMN_LONGITUDE,\r\n\t\t\t\t},\r\n\t\t\t\tDatabaseContract.SpeciesEntry._ID + \"= ?\", new String[]{Integer.toString(locationID)},\r\n\t\t\t\tnull, null, null\r\n\t\t);\r\n\t\tPair<Double, Double> location = null;\r\n\t\tif (cursor.moveToNext()) {\r\n\t\t\tlocation = new Pair<>(\r\n\t\t\t\t\tcursor.getDouble(cursor.getColumnIndex(DatabaseContract.LocationEntry.COLUMN_LATITUDE)),\r\n\t\t\t\t\tcursor.getDouble(cursor.getColumnIndex(DatabaseContract.LocationEntry.COLUMN_LONGITUDE))\r\n\t\t\t);\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\treturn location;\r\n\t}\r\n\t\r\n\tprivate List<Pair<String, String>> getAttributes(int subjectID, String tableName) {\r\n\t\tList<Pair<String, String>> attributes = new ArrayList<>();\r\n\t\tCursor cursor = database.rawQuery(\r\n\t\t\t\t\"select attributeCategories.\" + DatabaseContract.AttributeCategoryEntry.COLUMN_NAME + \" , \" +\r\n\t\t\t\t\t\t\" subjectAttributes.\" + DatabaseContract.AttributesColumns.COLUMN_ATTRIBUTE +\r\n\t\t\t\t\t\t\" from \" + tableName + \" as subjectAttributes inner join \" + DatabaseContract.AttributeCategoryEntry.TABLE_NAME + \" as attributeCategories on \" +\r\n\t\t\t\t\t\t\" subjectAttributes.\" + DatabaseContract.AttributesColumns.COLUMN_CATEGORY_ID + \" = attributeCategories.\" + DatabaseContract.AttributeCategoryEntry._ID +\r\n\t\t\t\t\t\t\" where subjectAttributes.\" + DatabaseContract.AttributesColumns.COLUMN_SUBJECT_ID + \"=? \" +\r\n\t\t\t\t\t\t\"order by attributeCategories.\" + DatabaseContract.AttributeCategoryEntry.COLUMN_POSITION + \" asc \",\r\n\t\t\t\tnew String[]{Integer.toString(subjectID)}\r\n\t\t);\r\n\t\twhile (cursor.moveToNext()) {\r\n\t\t\tattributes.add(new Pair<>(\r\n\t\t\t\t\t\t\tcursor.getString(cursor.getColumnIndex(DatabaseContract.AttributeCategoryEntry.COLUMN_NAME)),\r\n\t\t\t\t\t\t\tcursor.getString(cursor.getColumnIndex(DatabaseContract.AttributesColumns.COLUMN_ATTRIBUTE))\r\n\t\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t\tcursor.close();\r\n\t\treturn attributes;\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/zooverse/model/database/DatabaseHandler.java	(revision d9feccf0666b205182c3a433ef061347d72f52a4)
+++ app/src/main/java/com/zooverse/model/database/DatabaseHandler.java	(date 1616935913272)
@@ -24,7 +24,7 @@
 import java.util.Map;
 
 public class DatabaseHandler extends SQLiteAssetHelper {
-	private static final int DATABASE_VERSION = 60;
+	private static final int DATABASE_VERSION = 74;
 	
 	private static final SimpleDateFormat dateFormat = new SimpleDateFormat(DatabaseContract.DATE_FORMAT);
 	
Index: .idea/shelf/Uncommitted_changes_before_Checkout_at_07_03_21__11_03__Default_Changelist_.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Checkout_at_07_03_21__11_03__Default_Changelist_.xml	(revision d9feccf0666b205182c3a433ef061347d72f52a4)
+++ .idea/shelf/Uncommitted_changes_before_Checkout_at_07_03_21__11_03__Default_Changelist_.xml	(revision d9feccf0666b205182c3a433ef061347d72f52a4)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Checkout_at_07_03_21,_11_03_[Default_Changelist]" date="1615115022574" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_07_03_21,_11_03_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Checkout at 07.03.21, 11:03 [Default Changelist]" />
-</changelist>
\ No newline at end of file
